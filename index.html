
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer XII</title>
    <style>
        body {
            display: flex;
            flex-direction: row;
            background-color: #f4f4f4;
            color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: left;
        }

        img {
            max-width: 90%;
        }

        .navbar {
            position: fixed;
            width: 220px;
            height: 100%;
            background-color: #007BFF;
            padding: 15px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);/
        }

        .navbar h2 {
            margin: 0 0 15px;
            color: white;
            font-size: 1.5em;
        }

        .navbar ul li button {
            width: 100%;
            padding: 12px;
            background-color: #0056b3;
            border: none;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        .navbar ul li button:hover {
            background-color: #004494;
            transform: scale(1.05);
        }

        .content {
            margin-left: 240px;
            padding: 20px;
            text-align: left;
            line-height: 1.6;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .navbar {
            position: fixed;
            width: 200px;
            height: 100%;
            background-color: #1e31fdbc;
            padding: 10px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto;

        }

        .navbar h2 {
            margin: 0 0 10px;
            color: white;
        }

        .navbar ul {
            list-style-type: none;
            padding: 0;
        }

        .navbar ul li {
            margin: 5px 0;
        }

        .navbar ul li button {
            width: 100%;
            padding: 10px;
            background-color: #ffffffc2;
            border: none;
            color: rgb(0, 0, 0);
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .navbar ul li button:hover {
            background-color: #bdbdbd;
        }

        .content {
            margin: 0 auto;
            margin-left: 220px;
            padding: 10px;
            text-align: left;
            max-width: 75%;
        }
    </style>
</head>

<body>
    <div class="navbar">
        <h2>Content</h2>
        <ul>
            <li><button onclick="location.href='#index'">Index</button></li>
            <li><button onclick="location.href='#chapter1'">Chapter 1</button></li>
                        <li><button onclick="location.href='#questions'">Questions</button></li>
            <li><button onclick="location.href='#chapter2'">Chapter 2</button></li>
            <li><button onclick="location.href='#chapter3'">Chapter 3</button></li>
            <li><button onclick="location.href='#chapter4'">Chapter 4</button></li>
            <li><button onclick="location.href='#chapter5'">Chapter 5</button></li>
            <li><button onclick="location.href='#chapter6'">Chapter 6</button></li>
            <li><button onclick="location.href='#chapter7'">Chapter 7</button></li>


            <h2> &nbsp; </h2>
        </ul>
    </div>
    
    <div  class="content">
      <div id="index" class="scrollspy chapter">
            <blockquote class="title">
                <h1>Index</h1>
            </blockquote>
            
            <div class="content ck-content">
              <div style="overflow-x:auto;">
  <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr>
        <th>S.N.</th>
        <th>Topic</th>
        <th>Content wise marks</th>
        <th>Working hours</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>Database management system</td>
        <td>8</td>
        <td>12</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Data communication and networking</td>
        <td>9</td>
        <td>15</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Web Tech – II</td>
        <td>8</td>
        <td>12</td>
      </tr>
      <tr>
        <td>4</td>
        <td>C Programming II</td>
        <td>8</td>
        <td>12</td>
      </tr>
      <tr>
        <td>5</td>
        <td>Object oriented programming</td>
        <td>6</td>
        <td>10</td>
      </tr>
      <tr>
        <td>6</td>
        <td>Software development life cycle</td>
        <td>6</td>
        <td>10</td>
      </tr>
      <tr>
        <td>7</td>
        <td>Recent Trends in technology</td>
        <td>5</td>
        <td>9</td>
      </tr>
      <tr>
        <th colspan="2">Total</th>
        <th>50</th>
        <th>80</th>
      </tr>
    </tbody>
  </table>
</div>

            </div>
            </div>
      
        <div id="chapter1" class="scrollspy chapter">
            <blockquote class="title">
                <h1>Chapter 1: Database management system</h1>
            </blockquote>
            <div class="content ck-content">
                    <div>
  <h2>Data vs Information</h2>
  <p><strong>Data</strong> consists of raw facts and figures that by themselves do not carry meaning. These can be numbers, text, images, or sounds collected from various sources. Data alone cannot help in decision-making without interpretation. For example, a temperature reading of "30" is data until you know whether it's in Celsius or Fahrenheit, the location, or time.</p>
  <p><strong>Information</strong> is the processed form of data that is meaningful and useful. It results from organizing, structuring, or presenting data in context. For example, "The temperature in New York on June 15th was 30°C, which is higher than the average" is information because it adds context, making the data valuable for analysis or decisions.</p>
  <p>Understanding the distinction is crucial for fields like data science, business intelligence, and database management where the goal is to convert raw data into actionable information.</p>

  <h2>Features of Information</h2>
  <ul>
    <li><strong>Accuracy:</strong> Information must be precise and error-free. Inaccurate information can lead to poor decisions or business losses.</li>
    <li><strong>Timeliness:</strong> Information must be available when needed. Outdated information might be irrelevant or misleading.</li>
    <li><strong>Relevance:</strong> The information should be applicable to the purpose it serves, ensuring it meets the needs of users or processes.</li>
    <li><strong>Completeness:</strong> All necessary details should be present for the information to be fully understood and actionable.</li>
    <li><strong>Consistency:</strong> Information should be consistent across different sources and over time to build trust and reliability.</li>
    <li><strong>Understandability:</strong> Information should be presented clearly and understandably so that users can interpret it correctly.</li>
    <li><strong>Accessibility:</strong> Authorized users should be able to easily access the information when needed without unnecessary hurdles.</li>
  </ul>

  <h2>Database and Its Purpose</h2>
  <p>A <strong>database</strong> is a collection of related data organized systematically to facilitate easy access, management, and updating. Databases enable users to store vast amounts of information securely and retrieve it quickly using query languages like SQL.</p>
  <p>The primary purpose of a database is to support efficient data storage, retrieval, and manipulation, enabling applications to serve user needs effectively. Databases eliminate redundant data storage, provide data integrity, and support concurrent access by multiple users, which is essential in modern multi-user environments such as banking, e-commerce, and social networking.</p>
  <p>For example, in an online store, a database maintains records of products, customers, orders, and payments, allowing seamless operations like searching products, placing orders, and tracking shipments.</p>

  <h2>Terminologies in Database</h2>
  <ul>
    <li><strong>Table:</strong> The basic unit of data storage in relational databases. Each table contains rows (records) and columns (fields), representing entities such as employees or products.</li>
    <li><strong>Field:</strong> A column in a table, defining the data type and meaning of the data stored. For example, "Name," "Date of Birth," or "Price."</li>
    <li><strong>Record:</strong> A row in a table representing a single entity instance, such as a specific employee or product entry.</li>
    <li><strong>Tuple:</strong> Synonymous with a record, emphasizing its ordered structure in a table.</li>
    <li><strong>Object:</strong> In object-oriented or object-relational databases, an object is a data entity encapsulating attributes and behaviors, representing real-world entities more naturally.</li>
    <li><strong>Keys:</strong> Fields that uniquely identify records or establish relationships:
      <ul>
        <li><em>Primary Key:</em> A unique identifier for each record in a table (e.g., employee ID).</li>
        <li><em>Foreign Key:</em> A field in one table that links to the primary key in another, establishing relational connections.</li>
      </ul>
    </li>
  </ul>

  <h2>Data Dictionary</h2>
  <p>The <strong>data dictionary</strong> is an essential metadata repository in a database system that stores definitions, constraints, and structural information about data elements and their relationships. It acts as a blueprint, documenting the design and structure of the database to aid developers, DBAs, and users in understanding and managing the data.</p>
  <p>It typically includes:</p>
  <ul>
    <li>Table names and descriptions</li>
    <li>Field names, data types, and allowed values</li>
    <li>Relationships and constraints between tables</li>
    <li>Access permissions and user roles</li>
  </ul>
  <p>An accurate data dictionary is crucial for maintaining data integrity, consistency, and facilitating changes or upgrades in the database structure over time.</p>

  <h2>Database Management System (DBMS)</h2>
  <h3>Introduction</h3>
  <p>A <strong>DBMS</strong> is a sophisticated software system that provides an interface to define, create, query, update, and administer databases. It abstracts the complexity of data storage and management from users, enabling efficient handling of large data volumes and concurrent multi-user access.</p>
  <p>Popular DBMS examples include MySQL, Oracle, Microsoft SQL Server, and PostgreSQL, widely used in enterprise and web applications.</p>

  <h3>Objectives</h3>
  <ul>
    <li>Provide a convenient and efficient environment for users to store and retrieve data.</li>
    <li>Ensure data integrity, security, and privacy.</li>
    <li>Enable concurrent multi-user access with transaction management.</li>
    <li>Provide backup, recovery, and fault tolerance mechanisms.</li>
    <li>Maintain data independence by separating physical and logical data structures.</li>
  </ul>

  <h3>Advantages</h3>
  <ul>
    <li><strong>Data Integrity:</strong> DBMS enforces rules to maintain accuracy and consistency of data.</li>
    <li><strong>Security:</strong> Access controls restrict unauthorized data access and manipulation.</li>
    <li><strong>Reduced Redundancy:</strong> Data normalization eliminates duplication, saving storage and improving consistency.</li>
    <li><strong>Backup and Recovery:</strong> DBMS automates data backup and recovery, minimizing data loss risks.</li>
    <li><strong>Multi-User Access:</strong> Supports concurrent access while preventing conflicts through locking and transactions.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li><strong>Complexity:</strong> Setting up and managing a DBMS requires skilled personnel and planning.</li>
    <li><strong>Cost:</strong> Licensing, hardware, and maintenance can be expensive.</li>
    <li><strong>Performance Overhead:</strong> Additional layers of abstraction may impact speed compared to file-based systems.</li>
    <li><strong>Single Point of Failure:</strong> Centralized DBMS can cause system-wide downtime if not designed with fault tolerance.</li>
  </ul>

  <h2>Types of Database Models</h2>
  <ul>
    <li><strong>Hierarchical Model:</strong>
      <p>Organizes data in a tree-like structure with parent-child relationships, where each child record has only one parent. This model is efficient for representing structured data like organizational charts, XML data, or file systems. However, its rigid hierarchy limits flexibility in representing complex relationships.</p>
    </li>
    <li><strong>Network Model:</strong>
      <p>Extends the hierarchical model by allowing multiple parent records, forming a graph structure. This many-to-many relationship model supports more complex real-world scenarios such as supply chains or telecommunications. Though flexible, network models are complex to design and manage.</p>
    </li>
    <li><strong>Relational Model:</strong>
      <p>The most widely used model today, it stores data in tables (relations) with rows and columns. Data relationships are established using keys, and operations are performed using relational algebra and SQL. This model offers simplicity, data independence, and flexibility, making it suitable for most business applications.</p>
    </li>
    <li><strong>Entity-Relationship Model:</strong>
      <p>Primarily used for database design, this conceptual model uses diagrams (ER diagrams) to illustrate entities, attributes, and relationships. It helps in visualizing and planning the database structure before implementation.</p>
    </li>
  </ul>

  <h2>Integrity Constraints and Types</h2>
  <p>Integrity constraints enforce rules on data to ensure accuracy, consistency, and reliability in a database.</p>
  <ul>
    <li><strong>Domain Constraint:</strong> Defines the permissible set of values for a column, such as data type restrictions, value ranges, or formats (e.g., a date field must be a valid date).</li>
    <li><strong>Entity Integrity:</strong> Ensures that each table’s primary key is unique and not null, so every record is uniquely identifiable.</li>
    <li><strong>Referential Integrity:</strong> Maintains valid relationships between tables by ensuring foreign keys correspond to existing primary keys. It prevents orphan records and maintains relational consistency.</li>
    <li><strong>Key Constraints:</strong> Enforce uniqueness and correct usage of primary and foreign keys to maintain data consistency.</li>
  </ul>

  <h2>Normalization</h2>
  <h3>Introduction</h3>
  <p>Normalization is a systematic approach of decomposing tables to minimize data redundancy and eliminate undesirable characteristics like update, insert, and delete anomalies. It improves data integrity and efficiency in relational databases by organizing data into multiple related tables.</p>
  <p>Normalization follows several stages called normal forms, each with specific rules:</p>

  <h3>Normal Forms</h3>
  <ul>
    <li><strong>First Normal Form (1NF):</strong> Ensures that all table columns contain atomic, indivisible values, and there are no repeating groups or arrays within rows.</li>
    <li><strong>Second Normal Form (2NF):</strong> Achieved when the table is in 1NF and all non-key attributes are fully functionally dependent on the entire primary key, removing partial dependencies.</li>
    <li><strong>Third Normal Form (3NF):</strong> Reached when the table is in 2NF and all attributes are only dependent on the primary key, eliminating transitive dependencies.</li>
  </ul>

  <h3>Advantages of Normalization</h3>
  <ul>
    <li>Eliminates redundant data, reducing storage needs.</li>
    <li>Ensures data consistency and accuracy.</li>
    <li>Makes the database easier to maintain and update.</li>
    <li>Improves query performance by structuring data efficiently.</li>
  </ul>

  <h3>Disadvantages of Normalization</h3>
  <ul>
    <li>Increased number of tables can make queries more complex and slower due to joins.</li>
    <li>Over-normalization may result in performance bottlenecks.</li>
    <li>Sometimes denormalization is preferred for read-heavy applications to improve speed.</li>
  </ul>

  <h2>Centralized and Distributed Database</h2>
  <h3>Introduction</h3>
  <p><strong>Centralized Database</strong> systems store data in a single central location managed by one DBMS instance. All data access, processing, and administration occur on this central server.</p>
  <p><strong>Distributed Database</strong> systems distribute data across multiple physical locations, connected through a network but appear as a single database to users. This approach can enhance performance, fault tolerance, and scalability.</p>

  <h3>Advantages</h3>
  <ul>
    <li><strong>Centralized:</strong> Easier management, simplified backup, and strong data integrity due to centralized control.</li>
    <li><strong>Distributed:</strong> Improved reliability (no single point of failure), better performance by localizing data access, and scalability by adding nodes.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li><strong>Centralized:</strong> Potential bottlenecks and vulnerability to single points of failure.</li>
    <li><strong>Distributed:</strong> Complex data synchronization, possible consistency issues, and higher maintenance costs.</li>
  </ul>

  <h3>Comparison</h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>Feature</th>
        <th>Centralized Database</th>
        <th>Distributed Database</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Data Location</td>
        <td>Stored in one place</td>
        <td>Spread across multiple locations</td>
      </tr>
      <tr>
        <td>Management Complexity</td>
        <td>Simple</td>
        <td>Complex</td>
      </tr>
      <tr>
        <td>Fault Tolerance</td>
        <td>Low (single point of failure)</td>
        <td>High (redundant nodes)</td>
      </tr>
      <tr>
        <td>Performance</td>
        <td>Limited by server capability</td>
        <td>Potentially higher through parallelism</td>
      </tr>
      <tr>
        <td>Cost</td>
        <td>Lower initial cost</td>
        <td>Higher infrastructure and maintenance costs</td>
      </tr>
    </tbody>
  </table>

  <h2>Database Security</h2>
  <h3>Introduction</h3>
  <p>Database security involves protecting the database against unauthorized access, misuse, or theft. It is critical because databases often store sensitive information such as personal data, financial records, and proprietary business information.</p>

  <h3>Challenges</h3>
  <ul>
    <li>Preventing unauthorized access from hackers or malicious insiders.</li>
    <li>Protecting against SQL injection and other cyber attacks.</li>
    <li>Maintaining privacy and compliance with regulations such as GDPR or HIPAA.</li>
    <li>Ensuring data availability despite threats like denial of service attacks.</li>
  </ul>

  <h3>Security Measures</h3>
  <ul>
    <li><strong>Authentication:</strong> Verifying user identities through passwords, biometrics, or tokens.</li>
    <li><strong>Authorization:</strong> Granting appropriate access rights based on user roles.</li>
    <li><strong>Encryption:</strong> Protecting data at rest and in transit using cryptographic techniques.</li>
    <li><strong>Auditing:</strong> Keeping logs of access and modifications for accountability.</li>
    <li><strong>Backup and Recovery:</strong> Regularly backing up data to recover from security breaches or data loss.</li>
  </ul>

  <h3>Roles of DBA (Database Administrator)</h3>
  <p>The DBA plays a crucial role in managing database security, performance, and availability. Key responsibilities include:</p>
  <ul>
    <li>Installing and configuring the DBMS software.</li>
    <li>Defining and enforcing security policies.</li>
    <li>Performing backup and recovery operations.</li>
    <li>Monitoring system performance and tuning databases.</li>
    <li>Managing user accounts, roles, and privileges.</li>
    <li>Ensuring data integrity and compliance with regulations.</li>
  </ul>

  <h2>Practical Topics: DDL and DML Languages</h2>
  <p><strong>Data Definition Language (DDL)</strong> commands are used to define and modify database structures such as tables, indexes, and schemas. Common DDL commands include <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code>.</p>
  <p><strong>Data Manipulation Language (DML)</strong> commands are used to manipulate data stored within tables. These include <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code>.</p>

  <h2>SQL Data Types</h2>
  <p>SQL supports various data types to define the nature and constraints of data stored in table fields:</p>
  <ul>
    <li><strong>CHAR(size):</strong> Fixed-length character string. Useful for storing data with a fixed size, such as country codes.</li>
    <li><strong>VARCHAR(size):</strong> Variable-length character string. Efficient for storing text with varying lengths, like names or emails.</li>
    <li><strong>BINARY(size):</strong> Fixed-length binary data, used to store raw bytes.</li>
    <li><strong>VARBINARY(size):</strong> Variable-length binary data.</li>
    <li><strong>TINYBLOB:</strong> Very small binary large object (up to 255 bytes).</li>
    <li><strong>TINYTEXT:</strong> Very small text data.</li>
    <li><strong>TEXT:</strong> Large text data (up to 65,535 characters).</li>
    <li><strong>LONGTEXT:</strong> Very large text data (up to 4GB).</li>
    <li><strong>ENUM:</strong> A string object that can have one value chosen from a list of predefined values.</li>
    <li><strong>BIT:</strong> Stores bit-field values.</li>
    <li><strong>TINYINT:</strong> Very small integer (usually 1 byte).</li>
    <li><strong>BOOLEAN:</strong> Stores true or false values (often implemented as TINYINT).</li>
    <li><strong>INTEGER:</strong> Standard integer value.</li>
    <li><strong>FLOAT:</strong> Floating-point number with single precision.</li>
    <li><strong>DOUBLE:</strong> Floating-point number with double precision.</li>
    <li><strong>DECIMAL(p,s):</strong> Fixed-point number with precision <em>p</em> and scale <em>s</em>, suitable for financial calculations.</li>
    <li><strong>DATE:</strong> Stores calendar dates (year, month, day).</li>
    <li><strong>DATETIME:</strong> Stores date and time values.</li>
  </ul>

<h1>SQL JOINs Explained</h1>

<p>In SQL, <strong>JOIN</strong> operations combine rows from two or more tables based on a related column between them. The main types of JOINs are:</p>

<ul>
    <li><strong>INNER JOIN</strong></li>
    <li><strong>LEFT JOIN</strong> (or LEFT OUTER JOIN)</li>
    <li><strong>RIGHT JOIN</strong> (or RIGHT OUTER JOIN)</li>
    <li><strong>FULL JOIN</strong> (or FULL OUTER JOIN)</li>
</ul>

<h2>Sample Tables</h2>

<p>Consider the following two tables:</p>

<table border="1" cellpadding="5" cellspacing="0">
    <caption><strong>Table: Employees</strong></caption>
    <thead>
        <tr><th>EmployeeID</th><th>Name</th><th>DeptID</th></tr>
    </thead>
    <tbody>
        <tr><td>1</td><td>Alice</td><td>10</td></tr>
        <tr><td>2</td><td>Bob</td><td>20</td></tr>
        <tr><td>3</td><td>Charlie</td><td>30</td></tr>
        <tr><td>4</td><td>David</td><td>null</td></tr>
    </tbody>
</table>

<table border="1" cellpadding="5" cellspacing="0">
    <caption><strong>Table: Departments</strong></caption>
    <thead>
        <tr><th>DeptID</th><th>DeptName</th></tr>
    </thead>
    <tbody>
        <tr><td>10</td><td>HR</td></tr>
        <tr><td>20</td><td>IT</td></tr>
        <tr><td>40</td><td>Finance</td></tr>
    </tbody>
</table>

<h2>1. INNER JOIN</h2>
<p>Returns only the rows where there is a match in both tables.</p>

<pre><code>SELECT Employees.Name, Departments.DeptName
FROM Employees
INNER JOIN Departments ON Employees.DeptID = Departments.DeptID;
</code></pre>

<p><strong>Result:</strong></p>
<table border="1" cellpadding="5" cellspacing="0">
    <thead>
        <tr><th>Name</th><th>DeptName</th></tr>
    </thead>
    <tbody>
        <tr><td>Alice</td><td>HR</td></tr>
        <tr><td>Bob</td><td>IT</td></tr>
    </tbody>
</table>

<h2>2. LEFT JOIN (LEFT OUTER JOIN)</h2>
<p>Returns all rows from the left table (Employees), and matched rows from the right table (Departments). If no match, NULLs for the right table columns.</p>

<pre><code>SELECT Employees.Name, Departments.DeptName
FROM Employees
LEFT JOIN Departments ON Employees.DeptID = Departments.DeptID;
</code></pre>

<p><strong>Result:</strong></p>
<table border="1" cellpadding="5" cellspacing="0">
    <thead>
        <tr><th>Name</th><th>DeptName</th></tr>
    </thead>
    <tbody>
        <tr><td>Alice</td><td>HR</td></tr>
        <tr><td>Bob</td><td>IT</td></tr>
        <tr><td>Charlie</td><td>null</td></tr>
        <tr><td>David</td><td>null</td></tr>
    </tbody>
</table>

<h2>3. RIGHT JOIN (RIGHT OUTER JOIN)</h2>
<p>Returns all rows from the right table (Departments), and matched rows from the left table (Employees). If no match, NULLs for the left table columns.</p>

<pre><code>SELECT Employees.Name, Departments.DeptName
FROM Employees
RIGHT JOIN Departments ON Employees.DeptID = Departments.DeptID;
</code></pre>

<p><strong>Result:</strong></p>
<table border="1" cellpadding="5" cellspacing="0">
    <thead>
        <tr><th>Name</th><th>DeptName</th></tr>
    </thead>
    <tbody>
        <tr><td>Alice</td><td>HR</td></tr>
        <tr><td>Bob</td><td>IT</td></tr>
        <tr><td>null</td><td>Finance</td></tr>
    </tbody>
</table>

<h2>4. FULL JOIN (FULL OUTER JOIN)</h2>
<p>Returns all rows when there is a match in one of the tables. Rows without a match in either table will contain NULLs in place of missing columns.</p>

<pre><code>SELECT Employees.Name, Departments.DeptName
FROM Employees
FULL OUTER JOIN Departments ON Employees.DeptID = Departments.DeptID;
</code></pre>

<p><strong>Result:</strong></p>
<table border="1" cellpadding="5" cellspacing="0">
    <thead>
        <tr><th>Name</th><th>DeptName</th></tr>
    </thead>
    <tbody>
        <tr><td>Alice</td><td>HR</td></tr>
        <tr><td>Bob</td><td>IT</td></tr>
        <tr><td>Charlie</td><td>null</td></tr>
        <tr><td>David</td><td>null</td></tr>
        <tr><td>null</td><td>Finance</td></tr>
    </tbody>
</table>

</div>
         <div id="questions"></div>
  <h1 id="chapter1">DBMS Questions and Answers (2020-2024)</h1>
  <ol>
    <li>
      <strong>What is Database and DBMS? List out the advantages and disadvantages of DBMS.</strong><br>
      A database is an organized collection of data. DBMS (Database Management System) is software that manages databases.
      <br><strong>Advantages:</strong> Reduces data redundancy, ensures data integrity, supports multi-user access, enables backup and recovery.<br>
      <strong>Disadvantages:</strong> Expensive hardware/software, complex to manage, requires skilled personnel.
    </li>

    <li>
      <strong>Differentiate between file processing system and DBMS:</strong><br>
      1. File system has data redundancy; DBMS reduces it.<br>
      2. File system is application-dependent; DBMS is independent.<br>
      3. File system has limited security; DBMS has better security.<br>
      4. File system lacks backup/recovery; DBMS supports both.
    </li>

    <li>
      <strong>Explain different models of DBMS with advantages and disadvantages:</strong><br>
      - <strong>Hierarchical:</strong> Tree-like structure. Fast access but rigid.<br>
      - <strong>Network:</strong> Many-to-many relations. Flexible but complex.<br>
      - <strong>Relational:</strong> Uses tables. Easy to use and scalable but slower for complex data.<br>
      - <strong>Object-Oriented:</strong> Supports objects. Good for complex apps but less mature.
    </li>

    <li>
      <strong>What is a relational database? How is it different?</strong><br>
      A relational database stores data in tables with rows and columns. It's different due to its use of primary/foreign keys and structured query language (SQL).
    </li>

    <li>
      <strong>What is data redundancy? How does DBMS help in reducing it?</strong><br>
      Data redundancy is the duplication of data. DBMS reduces it by using normalization and shared access to a central database.
    </li>

    <li>
      <strong>Differentiate between centralized and distributed database systems:</strong><br>
      - Centralized: Data stored in one location. Easier to manage but less fault-tolerant.<br>
      - Distributed: Data distributed over multiple locations. More reliable but complex.
    </li>

    <li>
      <strong>Who is DBA? Responsibilities?</strong><br>
      DBA (Database Administrator) manages and maintains the database.<br>
      Responsibilities: Installation, configuration, backup, recovery, security, performance tuning.
    </li>

    <li>
      <strong>Define normalization. Explain 1NF, 2NF, 3NF:</strong><br>
      Normalization is the process of organizing data to reduce redundancy.<br>
      - <strong>1NF:</strong> No repeating groups. Example: Separate multiple phone numbers into rows.<br>
      - <strong>2NF:</strong> Remove partial dependencies. Every non-key attribute depends on whole primary key.<br>
      - <strong>3NF:</strong> Remove transitive dependencies. Non-key attributes should not depend on other non-key attributes.
    </li>

    <li>
      <strong>Explain primary key, foreign key, candidate key:</strong><br>
      - <strong>Primary key:</strong> Unique identifier (e.g., StudentID).<br>
      - <strong>Foreign key:</strong> Refers to primary key in another table.<br>
      - <strong>Candidate key:</strong> All possible keys that can become primary.
    </li>

    <li>
      <strong>What is SQL? Explain components and functions:</strong><br>
      SQL (Structured Query Language) is used to interact with databases.<br>
      - <strong>Components:</strong> DDL, DML, DCL, TCL.<br>
      - <strong>Functions:</strong> SELECT, INSERT, UPDATE, DELETE, JOINs, etc.
    </li>

  <h2>SQL Code Example with Database and Multiple Insertions</h2>
  <pre><code>
Create the table
CREATE TABLE students (
  Id INT PRIMARY KEY,
  Name VARCHAR(50),
  Class VARCHAR(20),
  Marks INT
);
<img src="1.1.png">
Insert records into the table
INSERT INTO students VALUES (1, 'Anita', 'XI', 78);
INSERT INTO students VALUES (2, 'Sita', 'XI', 83);
INSERT INTO students VALUES (3, 'Bikash', 'XI', 67);
INSERT INTO students VALUES (4, 'Prakash', 'XI', 90);
INSERT INTO students VALUES (5, 'Laxmi', 'XI', 75);
<img src="1.2.png">

Display all records
SELECT * FROM students;
<img src="1.3.png">
Update marks of student named 'Anita'
UPDATE students SET Marks = 85 WHERE Name = 'Anita';
<img src="1.4.png">
<img src="1.4.1.png">
Delete record of student with id = 3
DELETE FROM students WHERE Id = 3;</code></pre>

    <li>
      <strong>Define the following terms:</strong>
      <ol type="a">
        <li><strong>Data Dictionary:</strong> Metadata about database structure.</li>
        <li><strong>Primary Key:</strong> Unique column identifying a record.</li>
        <li><strong>Relationship:</strong> Association between tables using keys.</li>
        <li><strong>DML:</strong> Data Manipulation Language (e.g., SELECT, INSERT).</li>
        <li><strong>SQL:</strong> Language to manage and query databases.</li>
        <li><strong>Data Integrity:</strong> Accuracy and consistency of data.</li>
        <li><strong>DDL:</strong> Data Definition Language (e.g., CREATE, ALTER).</li>
        <li><strong>Data Security:</strong> Protecting data from unauthorized access.</li>
        <li><strong>Database System:</strong> The database + DBMS software + users + applications.</li>
      </ol>
    </li>
  </ol>

    <h1 id="chapter2">Unit 2 – C Programming</h1>
  <ol>
    <li>
      <strong>Working with a function:</strong>
      <ol type="a">
        <li><strong>Define function:</strong> A function is a block of code that performs a specific task and can be reused.</li>
        <li><strong>Syntax of functions:</strong><br>
          <code>return_type function_name(parameters) { //code }</code>
        </li>
        <li><strong>Types of functions:</strong><br>
          - <strong>Library Functions:</strong> Predefined (e.g., <code>printf()</code>, <code>scanf()</code>)<br>
          - <strong>User Defined Functions:</strong> Created by users for specific tasks
        </li>
        <li><strong>Components of function:</strong>
          <ol type="i">
            <li><strong>Function prototype:</strong> Declaration (e.g., <code>int add(int, int);</code>)</li>
            <li><strong>Function call:</strong> Usage (e.g., <code>add(2, 3);</code>)</li>
            <li><strong>Function definition:</strong> Body (e.g., <code>int add(int a, int b) { return a + b; }</code>)</li>
            <li><strong>Return type:</strong> Specifies what type of value function returns (e.g., <code>int</code>, <code>void</code>)</li>
          </ol>
        </li>
      </ol>
    </li>
    <li>
  <h2>Variable and Its Scope in C Programming</h2>
  <p>In C programming, the <strong>scope</strong> of a variable determines where that variable is accessible within the code. There are two primary scopes for variables:</p>

  <h3>1. Local Variables</h3>
  <p>Local variables are declared inside a function or a block and can only be accessed within that function or block. They are created when the function is called and destroyed when the function exits.</p>

  <pre><code>void func() {
    int localVar = 10;  // Local variable
    printf("%d\n", localVar);
  }</code></pre>

  <p>Here, <code>localVar</code> is accessible only inside <code>func()</code>. Trying to use it outside the function will cause an error.</p>

  <h3>2. Global Variables</h3>
  <p>Global variables are declared outside all functions, usually at the top of the program file. They can be accessed and modified by any function within the file.</p>

  <pre><code>int globalVar = 20;  // Global variable

void func() {
    printf("%d\n", globalVar);  // Access global variable
}

int main() {
    func();
    return 0;
}</code></pre>

  <p>Global variables exist for the lifetime of the program and are visible to all functions after their declaration.</p>

</li>
    <li>
      <strong>Categories of function with example:</strong>
      <ol type="i">
        <li><strong>Function with return type but no arguments:</strong>
          <pre><code>#include &lt;stdio.h&gt;

int getValue() {
  int value = 42;
  printf("Inside getValue function...\n");
  return value;
}

int main() {
  printf("Calling getValue()...\n");
  int result = getValue();
  printf("The value is: %d\n", result);
  printf("Executed by Rhythm Malla 948\n");
  return 0;
}</code></pre>
        </li>
         <img src="2.1.png">
        <li><strong>Function with return type with arguments:</strong>
          <pre><code>#include &lt;stdio.h&gt;

int multiply(int a, int b) {
  printf("Multiplying %d and %d...\n", a, b);
  int product = a * b;
  return product;
}

int main() {
  int x = 6, y = 7;
  printf("Calling multiply(%d, %d)...\n", x, y);
  int result = multiply(x, y);
  printf("Product: %d\n", result);
  printf("Executed by Rhythm Malla 948\n");
  return 0;
}</code></pre>
        </li>         <img src="2.2.png">
        <li><strong>Function with no return type with no arguments:</strong>
          <pre><code>#include &lt;stdio.h&gt;

void greet() {
  printf("Welcome to C Programming!\n");
  printf("This is a simple greeting message.\n");
}

int main() {
  printf("Calling greet()...\n");
  greet();
  printf("greet() function executed.\n");
  printf("Executed by Rhythm Malla 948\n");
  return 0;
}</code></pre>
        </li>         <img src="2.3.png">
        <li><strong>Function with no return type with arguments:</strong>
          <pre><code>#include &lt;stdio.h&gt;

void displaySum(int x, int y) {
  int sum = x + y;
  printf("Calculating sum of %d and %d...\n", x, y);
  printf("The sum is: %d\n", sum);
}

int main() {
  int a = 12, b = 8;
  printf("Calling displaySum(%d, %d)...\n", a, b);
  displaySum(a, b);
  printf("Executed by Rhythm Malla 948\n");
  return 0;
}</code></pre>
        </li>
      </ol>
    </li>
         <img src="2.4.png">
    <li>
      <strong>Storage classes:</strong>
      <p>In C, storage classes define the scope (visibility) and lifetime of variables and/or functions within a C Program. The four types of storage classes are:</p>
      <ul>
        <li><strong>Automatic:</strong> Default for all local variables. Declared inside a block or function. Keyword: <code>auto</code>.</li>
        <li><strong>External:</strong> Used to declare global variables accessible across multiple files. Keyword: <code>extern</code>.</li>
        <li><strong>Register:</strong> Stores variables in CPU registers for faster access. Keyword: <code>register</code>.</li>
        <li><strong>Static:</strong> Retains the value of a variable across function calls. Keyword: <code>static</code>.</li>
      </ul>
      <pre><code>#include &lt;stdio.h&gt;

int globalVar = 100; // external storage

void demoStatic() {
  static int counter = 0;
  counter++;
  printf("Static counter: %d\n", counter);
}

void demoRegister() {
  register int speed = 20;
  printf("Register speed: %d\n", speed);
}

void demoAuto() {
  auto int localValue = 10;
  printf("Automatic variable: %d\n", localValue);
}

int main() {
  printf("Global variable: %d\n", globalVar);
  demoStatic();
  demoStatic();
  demoRegister();
  demoAuto();
  printf("Executed by Rhythm Malla 948\n");
  return 0;
}</code></pre>
    </li>
         <img src="3.png">
    <li>
      <strong>Recursive function with syntax and examples:</strong><br>
      <p><strong>Syntax:</strong></p>
      <pre><code>return_type function_name(parameters) {
  if (base_condition) {
    return base_value;
  } else {
    return recursive_case;
  }
}</code></pre>
      <p><strong>Example:</strong></p>
      <pre><code>#include &lt;stdio.h&gt;

int factorial(int n) {
  if(n <= 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

int main() {
  int number = 5;
  printf("Finding factorial of %d...\n", number);
  int result = factorial(number);
  printf("Factorial of %d is %d\n", number, result);
  printf("Executed by Rhythm Malla 948\n");
  return 0;
}</code></pre>

<h2>Advantages and Disadvantages of Recursive Functions</h2>

  <h3>Advantages</h3>
  <ul>
    <li><strong>Simpler and Cleaner Code:</strong> Recursion can make complex problems easier to solve and understand by breaking them down into smaller subproblems.</li>
    <li><strong>Elegant Solutions for Problems with Recursive Structure:</strong> Problems like tree traversals, factorial calculation, and the Fibonacci sequence are naturally suited for recursion.</li>
    <li><strong>Reduces Code Size:</strong> Recursive solutions often require fewer lines of code compared to iterative solutions.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li><strong>Higher Memory Usage:</strong> Each recursive call adds a new layer to the call stack, which can lead to increased memory consumption.</li>
    <li><strong>Slower Performance:</strong> Recursive functions may be less efficient due to the overhead of multiple function calls.</li>
    <li><strong>Risk of Stack Overflow:</strong> Deep or infinite recursion can exhaust the call stack, causing the program to crash.</li>
    <li><strong>Sometimes Harder to Debug:</strong> Tracing recursive calls can be challenging, especially if the recursion is complex or not well understood.</li>
  </ul>
    </li>
         <img src="4.png">
    <li>
      <strong>Demonstration of passing array to a function:</strong>
      <p>The following program demonstrates passing an array to a function, calculating the average of the elements:</p>
      <pre><code>#include &lt;stdio.h&gt;

float calculateAverage(int arr[], int size) {
  int sum = 0;
  for (int i = 0; i &lt; size; i++) {
    sum += arr[i];
  }
  return (float)sum / size;
}

int main() {
  int numbers[] = {10, 20, 30, 40, 50};
  int size = sizeof(numbers) / sizeof(numbers[0]);
  printf("Passing array to function...\n");
  float avg = calculateAverage(numbers, size);
  printf("Average = %.2f\n", avg);
  printf("Executed by Rhythm Malla 948\n");
  return 0;
}</code></pre>
    </li>
     <img src="5.png">      
  </ol>
    <h2>Structure and Union in C Programming</h2>

  <h3>Structure</h3>
  
  <h4>Introduction and Syntax</h4>
  <p>A <strong>structure</strong> in C is a user-defined data type that groups different variables under one name. It allows combining data items of different kinds.</p>
  <pre><code>struct StructureName {
    data_type member1;
    data_type member2;
    // more members
};</code></pre>

  <h4>Structure Size</h4>
  <p>The size of a structure is at least the sum of the sizes of its members. However, padding may be added by the compiler for alignment purposes.</p>

  <h4>Accessing Members of Structure</h4>
  <pre><code>struct Point {
    int x;
    int y;
};

int main() {
    struct Point p1;
    p1.x = 10;
    p1.y = 20;
    printf("X = %d, Y = %d\n", p1.x, p1.y);
    return 0;
}</code></pre>

  <h4>Nested Structure</h4>
  <pre><code>struct Date {
    int day;
    int month;
    int year;
};

struct Student {
    char name[50];
    struct Date dob;  // Nested structure
};

int main() {
    struct Student s1 = { "Alice", {15, 8, 2000} };
    printf("Name: %s, DOB: %d/%d/%d\n", s1.name, s1.dob.day, s1.dob.month, s1.dob.year);
    return 0;
}</code></pre>

  <h4>Array of Structure</h4>
  <pre><code>struct Point {
    int x;
    int y;
};

int main() {
    struct Point points[3] = {{1,2}, {3,4}, {5,6}};
    for(int i = 0; i < 3; i++) {
        printf("Point %d: (%d, %d)\n", i+1, points[i].x, points[i].y);
    }
    return 0;
}</code></pre>

  <h4>Passing Structure to Function</h4>
  <pre><code>struct Point {
    int x;
    int y;
};

void printPoint(struct Point p) {
    printf("Point: (%d, %d)\n", p.x, p.y);
}

int main() {
    struct Point p1 = {10, 20};
    printPoint(p1);
    return 0;
}</code></pre>

  <hr>

  <h3>Union</h3>

  <h4>Introduction and Syntax</h4>
  <p>A <strong>union</strong> is similar to a structure but shares the same memory location for all its members. Only one member can contain a value at a time.</p>
  <pre><code>union UnionName {
    data_type member1;
    data_type member2;
    // more members
};</code></pre>

  <h4>Comparison between Structure and Union</h4>
  <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse;">
    <thead>
      <tr>
        <th>Feature</th>
        <th>Structure</th>
        <th>Union</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Memory Allocation</td>
        <td>Allocates separate memory for each member.</td>
        <td>All members share the same memory location.</td>
      </tr>
      <tr>
        <td>Size</td>
        <td>Sum of sizes of all members (plus padding).</td>
        <td>Size of the largest member.</td>
      </tr>
      <tr>
        <td>Usage</td>
        <td>Stores multiple values simultaneously.</td>
        <td>Stores one value at a time.</td>
      </tr>
      <tr>
        <td>Access</td>
        <td>All members can be accessed independently.</td>
        <td>Only one member can hold a valid value at a time.</td>
      </tr>
      <tr>
        <td>Typical Use Cases</td>
        <td>When grouping related data of different types.</td>
        <td>When saving memory and storing one of several possible values.</td>
      </tr>
    </tbody>
  </table>
      <h2>Pointers in C Programming</h2>

  <h3>Introduction and Syntax</h3>
  <p>A <strong>pointer</strong> is a variable that stores the memory address of another variable. It "points" to the location in memory where the data is stored.</p>
  <pre><code>data_type *pointer_name;</code></pre>
  <p>Example:</p>
  <pre><code>int *p;</code></pre>

  <h3>Usage and Working</h3>
  <p>Pointers are used for dynamic memory allocation, arrays, strings, and to efficiently pass large structures or arrays to functions.</p>
  <p>They allow indirect access to variables and enable functions to modify variables outside their scope.</p>

  <h3>Concept of Value and Address</h3>
  <ul>
    <li><strong>Value:</strong> The actual data stored in a variable.</li>
    <li><strong>Address:</strong> The location in memory where the data is stored.</li>
  </ul>
  <p>Example:</p>
  <pre><code>int a = 10;
int *p = &a;  // &a gives the address of variable a
printf("Value of a = %d\n", *p);  // Dereferencing pointer to get value
printf("Address of a = %p\n", p);  // Printing address stored in pointer</code></pre>

  <h3>Declaration and Initialization</h3>
  <pre><code>int a = 5;
int *p = &a;  // p holds address of a</code></pre>

  <h3>Pointer and Function</h3>
  <p>Passing pointers to functions allows modifying the actual variables.</p>
  <pre><code>void increment(int *ptr) {
    (*ptr)++;  // Increment the value at the address ptr points to
}

int main() {
    int num = 10;
    increment(&num);
    printf("Incremented value: %d\n", num);  // Outputs 11
    return 0;
}</code></pre>

  <h3>Call by Reference</h3>
  <p>Call by reference passes the address of a variable to the function, allowing it to modify the original variable.</p>
  <pre><code>void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 5, b = 10;
    swap(&a, &b);
    printf("a = %d, b = %d\n", a, b);  // Outputs: a = 10, b = 5
    return 0;
}</code></pre>

  <h3>Comparison between Call by Value and Call by Reference</h3>
  <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse;">
    <thead>
      <tr>
        <th>Feature</th>
        <th>Call by Value</th>
        <th>Call by Reference</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Parameter Passing</td>
        <td>Copies the value of the argument to the parameter.</td>
        <td>Passes the address of the argument.</td>
      </tr>
      <tr>
        <td>Effect on Original Variable</td>
        <td>Original variable is not modified.</td>
        <td>Original variable can be modified.</td>
      </tr>
      <tr>
        <td>Memory Usage</td>
        <td>Uses extra memory to copy values.</td>
        <td>More efficient as no copying is done.</td>
      </tr>
      <tr>
        <td>Use Case</td>
        <td>When original data should remain unchanged.</td>
        <td>When function needs to modify caller’s data.</td>
      </tr>
    </tbody>
  </table>

  <h3>Pointer with Arrays</h3>
  <p>Arrays and pointers are closely related in C. The name of an array acts like a pointer to its first element.</p>
  <pre><code>int arr[3] = {10, 20, 30};
int *p = arr;  // Points to arr[0]

for(int i = 0; i < 3; i++) {
    printf("%d ", *(p + i));  // Access array elements using pointer arithmetic
}
// Output: 10 20 30</code></pre>

  <h3>Advantages and Disadvantages</h3>
  <h4>Advantages</h4>
  <ul>
    <li>Efficient access to memory and arrays.</li>
    <li>Allows dynamic memory management.</li>
    <li>Enables functions to modify variables by reference.</li>
    <li>Useful in implementing complex data structures (linked lists, trees).</li>
  </ul>

  <h4>Disadvantages</h4>
  <ul>
    <li>Complex syntax can be confusing for beginners.</li>
    <li>Incorrect pointer use can cause runtime errors and crashes.</li>
    <li>Poor pointer management may lead to memory leaks.</li>
    <li>Debugging pointer-related bugs is often difficult.</li>
  </ul>

  <div>
  <h2>File Handling in C Programming</h2>

  <h3>Concept of Data File</h3>
  <p>A <strong>data file</strong> is a collection of related data stored on a secondary storage device such as a hard drive. Files allow data to be stored permanently and retrieved later.</p>

  <h3>Need for File Handling</h3>
  <p>File handling allows programs to:</p>
  <ul>
    <li>Store data permanently beyond the lifetime of a program.</li>
    <li>Read data from or write data to files for later use.</li>
    <li>Manage large amounts of data efficiently.</li>
    <li>Share data between different programs.</li>
  </ul>

  <h3>Sequential and Random Files</h3>
  <ul>
    <li><strong>Sequential Files:</strong> Data is processed in a linear sequence, one record after another from beginning to end.</li>
    <li><strong>Random (Direct) Files:</strong> Data can be accessed at any location directly without reading through all preceding data.</li>
  </ul>

  <h3>File Handling Functions</h3>
  <p>Below are common file handling functions in C, along with their purpose and syntax:</p>

  <h4>1. <code>fopen()</code> and <code>fclose()</code></h4>
  <p><code>fopen()</code> opens a file and returns a pointer to a <code>FILE</code> object. <code>fclose()</code> closes the file.</p>
  <pre><code>FILE *fopen(const char *filename, const char *mode);
int fclose(FILE *stream);</code></pre>
  <p><em>Modes example:</em> "r" (read), "w" (write), "a" (append), "rb" (read binary), etc.</p>

  <h4>2. <code>getc()</code> and <code>putc()</code></h4>
  <p>Read and write a single character to/from a file.</p>
  <pre><code>int getc(FILE *stream);
int putc(int char, FILE *stream);</code></pre>

  <h4>3. <code>fprintf()</code> and <code>fscanf()</code></h4>
  <p>Formatted output/input to/from a file, similar to <code>printf</code> and <code>scanf</code>.</p>
  <pre><code>int fprintf(FILE *stream, const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);</code></pre>

  <h4>4. <code>getw()</code> and <code>putw()</code></h4>
  <p>Read and write an integer from/to a file (note: not portable, use with caution).</p>
  <pre><code>int getw(FILE *stream);
int putw(int w, FILE *stream);</code></pre>

  <h4>5. <code>fgets()</code> and <code>fputs()</code></h4>
  <p>Read/write a string (line) from/to a file.</p>
  <pre><code>char *fgets(char *str, int n, FILE *stream);
int fputs(const char *str, FILE *stream);</code></pre>

  <h4>6. <code>fread()</code> and <code>fwrite()</code></h4>
  <p>Read/write blocks of data (binary) from/to a file.</p>
  <pre><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code></pre>

  <h4>7. <code>remove()</code> and <code>rename()</code></h4>
  <p>Delete or rename a file.</p>
  <pre><code>int remove(const char *filename);
int rename(const char *oldname, const char *newname);</code></pre>

  <h3>Random Access Functions</h3>
  <p>These functions allow manipulating the file position indicator for random access to files:</p>

  <h4><code>fseek()</code></h4>
  <p>Sets the file position to a specific location.</p>
  <pre><code>int fseek(FILE *stream, long int offset, int origin);</code></pre>
  <p><em>Parameters:</em></p>
  <ul>
    <li><code>offset</code>: Number of bytes to move the position indicator.</li>
    <li><code>origin</code>: Position from which offset is added. It can be:</li>
    <ul>
      <li><code>SEEK_SET</code> - Beginning of file</li>
      <li><code>SEEK_CUR</code> - Current position</li>
      <li><code>SEEK_END</code> - End of file</li>
    </ul>
  </ul>

  <h4><code>rewind()</code></h4>
  <p>Sets the file position to the beginning of the file (equivalent to <code>fseek(stream, 0, SEEK_SET)</code>).</p>
  <pre><code>void rewind(FILE *stream);</code></pre>

  <h4><code>ftell()</code></h4>
  <p>Returns the current position of the file pointer.</p>
  <pre><code>long int ftell(FILE *stream);</code></pre>

</div>

<div>
  <h2>File Opening Modes in C</h2>

  <h3>Read Modes</h3>
  <ul>
    <li><code>r</code>: Opens a file for reading. The file must exist.</li>
    <li><code>r+</code>: Opens a file for both reading and writing. The file must exist.</li>
  </ul>

  <h3>Write Modes</h3>
  <ul>
    <li><code>w</code>: Opens a file for writing. If the file exists, its content is erased. If the file does not exist, it is created.</li>
    <li><code>w+</code>: Opens a file for both reading and writing. If the file exists, it is truncated. Otherwise, a new file is created.</li>
  </ul>

  <h3>Append Modes</h3>
  <ul>
    <li><code>a</code>: Opens a file for writing in append mode. Data is added at the end of the file. If the file does not exist, it is created.</li>
    <li><code>a+</code>: Opens a file for both reading and writing in append mode. Writes are always at the end, but reading can be anywhere. Creates file if it does not exist.</li>
  </ul>

  <h2>Steps to Work with Files in C</h2>
  <ol>
    <li><strong>Define a File Pointer:</strong> Declare a variable of type <code>FILE *</code>.</li>
    <li><strong>Open the File with Required Mode:</strong> Use <code>fopen()</code> to open the file.</li>
    <li><strong>Perform Read, Write, or Append Operations:</strong> Use appropriate functions like <code>fgetc()</code>, <code>fputc()</code>, <code>fread()</code>, <code>fwrite()</code>, etc.</li>
    <li><strong>Close the File:</strong> Use <code>fclose()</code> to close the file and free resources.</li>
  </ol>

  <h3>Reading Data from Files</h3>
  <p>Use functions like <code>fgetc()</code>, <code>fgets()</code>, <code>fread()</code>, or <code>fscanf()</code> to read data from files.</p>

  <h3>Writing Data to Files</h3>
  <p>Use functions like <code>fputc()</code>, <code>fputs()</code>, <code>fwrite()</code>, or <code>fprintf()</code> to write data to files.</p>

  <h3>Appending Data to Files</h3>
  <p>Open the file in append mode (<code>a</code> or <code>a+</code>) to add data at the end without overwriting existing content.</p>

  <h3>End of File (EOF)</h3>
  <p><code>EOF</code> is a macro defined in <code>stdio.h</code> indicating the end of a file. Reading functions return <code>EOF</code> when the end is reached.</p>
  <pre><code>int ch;
while ((ch = fgetc(filePtr)) != EOF) {
    putchar(ch);
}</code></pre>

  <h2><code>typedef</code> Keyword in C</h2>
  <p><code>typedef</code> allows you to create new names (aliases) for existing data types, making code more readable and easier to manage.</p>
  <pre><code>typedef unsigned int uint;

uint age = 25;</code></pre>
  <p>It is commonly used to simplify complex types such as structures:</p>
  <pre><code>typedef struct {
    int x;
    int y;
} Point;

Point p1 = {10, 20};</code></pre>
</div>
      
    </div>
    </div>
</body>

</html>
